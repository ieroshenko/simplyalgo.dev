-- Blind 75 Migration - Part 3: Final Problems
-- Complete the remaining Blind 75 problems

INSERT INTO problems (id, title, difficulty, category_id, description, function_signature, examples, constraints, hints, likes, dislikes, acceptance_rate) VALUES

-- Trees (15 problems)
('diameter-of-binary-tree', 'Diameter of Binary Tree', 'Easy',
 (SELECT id FROM categories WHERE name = 'Trees'),
 'Given the root of a binary tree, return the length of the diameter of the tree.',
 'def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:',
 '[{"input": "root = [1,2,3,4,5]", "output": "3"}]'::jsonb,
 '["The number of nodes in the tree is in the range [1, 10^4]"]'::jsonb,
 '["The diameter passes through root or doesnt", "Use recursion"]'::jsonb,
 3456, 123, 49.8),

('balanced-binary-tree', 'Balanced Binary Tree', 'Easy',
 (SELECT id FROM categories WHERE name = 'Trees'),
 'Given a binary tree, determine if it is height-balanced.',
 'def isBalanced(self, root: Optional[TreeNode]) -> bool:',
 '[{"input": "root = [3,9,20,null,null,15,7]", "output": "true"}]'::jsonb,
 '["The number of nodes in the tree is in the range [0, 5000]"]'::jsonb,
 '["Check height difference at each node", "Use recursion"]'::jsonb,
 2890, 156, 45.2),

('binary-tree-maximum-path-sum', 'Binary Tree Maximum Path Sum', 'Hard',
 (SELECT id FROM categories WHERE name = 'Trees'),
 'A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them.',
 'def maxPathSum(self, root: Optional[TreeNode]) -> int:',
 '[{"input": "root = [1,2,3]", "output": "6"}]'::jsonb,
 '["The number of nodes in the tree is in the range [1, 3 * 10^4]"]'::jsonb,
 '["Path can start and end at any node", "Use recursion with global max"]'::jsonb,
 4567, 234, 37.1),

('serialize-and-deserialize-binary-tree', 'Serialize and Deserialize Binary Tree', 'Hard',
 (SELECT id FROM categories WHERE name = 'Trees'),
 'Design an algorithm to serialize and deserialize a binary tree.',
 'class Codec:\n    def serialize(self, root):\n    def deserialize(self, data):',
 '[{"input": "root = [1,2,3,null,null,4,5]", "output": "[1,2,3,null,null,4,5]"}]'::jsonb,
 '["The number of nodes in the tree is in the range [0, 10^4]"]'::jsonb,
 '["Use preorder traversal", "Handle null nodes"]'::jsonb,
 3210, 98, 52.7),

-- Tries (3 problems)
('implement-trie-prefix-tree', 'Implement Trie (Prefix Tree)', 'Medium',
 (SELECT id FROM categories WHERE name = 'Tries'),
 'A trie or prefix tree is a tree data structure used to efficiently store and search a dataset of strings.',
 'class Trie:\n    def __init__(self):\n    def insert(self, word: str) -> None:\n    def search(self, word: str) -> bool:\n    def startsWith(self, prefix: str) -> bool:',
 '[{"input": "[\"Trie\",\"insert\",\"search\",\"search\",\"startsWith\",\"insert\",\"search\"]", "output": "[null,null,false,true,true,null,true]"}]'::jsonb,
 '["1 <= word.length, prefix.length <= 2000", "word and prefix consist only of lowercase English letters"]'::jsonb,
 '["Use nested dictionary", "Each node has children and isEnd flag"]'::jsonb,
 4567, 123, 58.9),

('design-add-and-search-words-data-structure', 'Design Add and Search Words Data Structure', 'Medium',
 (SELECT id FROM categories WHERE name = 'Tries'),
 'Design a data structure that supports adding new words and finding if a string matches any previously added string.',
 'class WordDictionary:\n    def __init__(self):\n    def addWord(self, word: str) -> None:\n    def search(self, word: str) -> bool:',
 '[{"input": "[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]", "output": "[null,null,null,null,false,true,true,true]"}]'::jsonb,
 '["1 <= word.length <= 25", "word in addWord consists of lowercase English letters", "word in search consist of . or lowercase English letters"]'::jsonb,
 '["Use trie with DFS for wildcards", "Handle . character with recursion"]'::jsonb,
 2890, 167, 41.3),

('word-search-ii', 'Word Search II', 'Hard',
 (SELECT id FROM categories WHERE name = 'Tries'),
 'Given an m x n board of characters and a list of strings words, return all words on the board.',
 'def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:',
 '[{"input": "board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]", "output": "[\"eat\",\"oath\"]"}]'::jsonb,
 '["m == board.length", "n == board[i].length", "1 <= m, n <= 12", "1 <= words.length <= 3 * 10^4"]'::jsonb,
 '["Build trie from words", "DFS with backtracking", "Prune trie for optimization"]'::jsonb,
 3456, 234, 36.7),

-- Heap / Priority Queue (3 problems)
('find-median-from-data-stream', 'Find Median from Data Stream', 'Hard',
 (SELECT id FROM categories WHERE name = 'Heap / Priority Queue'),
 'The median is the middle value in an ordered integer list.',
 'class MedianFinder:\n    def __init__(self):\n    def addNum(self, num: int) -> None:\n    def findMedian(self) -> float:',
 '[{"input": "[\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"]", "output": "[null,null,null,1.5,null,2.0]"}]'::jsonb,
 '["-10^5 <= num <= 10^5", "There will be at least one element before calling findMedian"]'::jsonb,
 '["Use two heaps: max heap for left half, min heap for right half", "Balance heap sizes"]'::jsonb,
 4789, 189, 49.6),

-- Backtracking (5 problems)
('combination-sum', 'Combination Sum', 'Medium',
 (SELECT id FROM categories WHERE name = 'Backtracking'),
 'Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations.',
 'def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:',
 '[{"input": "candidates = [2,3,6,7], target = 7", "output": "[[2,2,3],[7]]"}]'::jsonb,
 '["1 <= candidates.length <= 30", "2 <= candidates[i] <= 40", "1 <= target <= 40"]'::jsonb,
 '["Use backtracking", "Allow reusing same number", "Sort array for optimization"]'::jsonb,
 6789, 234, 68.9),

('word-search', 'Word Search', 'Medium',
 (SELECT id FROM categories WHERE name = 'Backtracking'),
 'Given an m x n grid of characters board and a string word, return true if word exists in the grid.',
 'def exist(self, board: List[List[str]], word: str) -> bool:',
 '[{"input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"", "output": "true"}]'::jsonb,
 '["m == board.length", "n = board[i].length", "1 <= m, n <= 6", "1 <= word.length <= 15"]'::jsonb,
 '["DFS with backtracking", "Mark visited cells", "Restore state after backtrack"]'::jsonb,
 4567, 123, 40.1),

-- Graphs (7 problems)
('number-of-islands', 'Number of Islands', 'Medium',
 (SELECT id FROM categories WHERE name = 'Graphs'),
 'Given an m x n 2D binary grid which represents a map of 1s (land) and 0s (water), return the number of islands.',
 'def numIslands(self, grid: List[List[str]]) -> int:',
 '[{"input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]", "output": "1"}]'::jsonb,
 '["m == grid.length", "n == grid[i].length", "1 <= m, n <= 300"]'::jsonb,
 '["Use DFS or BFS", "Mark visited cells", "Count connected components"]'::jsonb,
 7890, 234, 58.4),

('clone-graph', 'Clone Graph', 'Medium',
 (SELECT id FROM categories WHERE name = 'Graphs'),
 'Given a reference of a node in a connected undirected graph, return a deep copy of the graph.',
 'def cloneGraph(self, node: Optional[''Node'']) -> Optional[''Node'']:',
 '[{"input": "adjList = [[2,4],[1,3],[2,4],[1,3]]", "output": "[[2,4],[1,3],[2,4],[1,3]]"}]'::jsonb,
 '["The number of nodes in the graph is in the range [0, 100]", "1 <= Node.val <= 100"]'::jsonb,
 '["Use DFS with hashmap", "Map original nodes to cloned nodes"]'::jsonb,
 3456, 167, 48.9),

('pacific-atlantic-water-flow', 'Pacific Atlantic Water Flow', 'Medium',
 (SELECT id FROM categories WHERE name = 'Graphs'),
 'There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean.',
 'def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:',
 '[{"input": "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]", "output": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]"}]'::jsonb,
 '["m == heights.length", "n == heights[r].length", "1 <= m, n <= 200"]'::jsonb,
 '["Start DFS from ocean borders", "Track cells reachable by each ocean"]'::jsonb,
 2890, 134, 52.7),

('course-schedule', 'Course Schedule', 'Medium',
 (SELECT id FROM categories WHERE name = 'Graphs'),
 'There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1.',
 'def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:',
 '[{"input": "numCourses = 2, prerequisites = [[1,0]]", "output": "true"}]'::jsonb,
 '["1 <= numCourses <= 2000", "0 <= prerequisites.length <= 5000"]'::jsonb,
 '["Detect cycle in directed graph", "Use DFS with coloring or topological sort"]'::jsonb,
 5678, 234, 46.3),

-- Advanced Graphs (1 problem)
('alien-dictionary', 'Alien Dictionary', 'Hard',
 (SELECT id FROM categories WHERE name = 'Advanced Graphs'),
 'There is a new alien language that uses the English alphabet. The order among the letters is unknown to you.',
 'def alienOrder(self, words: List[str]) -> str:',
 '[{"input": "words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]", "output": "\"wertf\""}]'::jsonb,
 '["1 <= words.length <= 100", "1 <= words[i].length <= 100"]'::jsonb,
 '["Build graph from word comparisons", "Topological sort", "Detect cycles"]'::jsonb,
 2345, 189, 33.8)

ON CONFLICT (id) DO NOTHING;